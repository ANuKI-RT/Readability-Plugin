package de.uni_passau.fim.readability_plugin.dialogues;

import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.progress.ProgressIndicator;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.progress.Task;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.wm.*;
import com.intellij.ui.components.JBScrollPane;
import com.intellij.ui.components.JBTabbedPane;
import com.intellij.ui.content.Content;
import com.intellij.ui.content.ContentFactory;
import com.intellij.ui.content.ContentManager;
import com.intellij.ui.treeStructure.Tree;
import de.uni_passau.fim.readability_plugin.java_parsing.JavaParseTree;
import de.uni_passau.fim.readability_plugin.painting.RatedJavaScope;
import de.uni_passau.fim.readability_plugin.readability.ReadabilityImprover;
import de.uni_passau.fim.readability_plugin.readability.ReadabilityImprover.Improvement;
import de.uni_passau.fim.readability_plugin.readability.ReadabilityProcessException;
import de.uni_passau.fim.readability_plugin.readability.ReadabilityResult;
import de.uni_passau.fim.readability_plugin.services.ReadabilityService;
import freemarker.template.TemplateException;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import java.awt.*;
import java.io.IOException;
import java.util.*;
import java.util.List;
import java.util.concurrent.*;

/**
 * This dialogue implements the ui for the readability details.
 * The following ui components can be rendered:
 *
 * 1. readability tree
 * Using this class the readability values of the different scopes in the java code can be
 * displayed as a tree.
 *
 * 2. readability hints
 * The plugin can display readability hints for a given method. These hints can b rendered using the methods of this
 * class
 */
public class ReadabilityDetailsDialogue {

    private Project project;
    private RatedJavaScope ratedMethod;
    private ReadabilityService readabilityService;
    private int totalProgressSteps;
    private static Map<String,DefaultMutableTreeNode> treeCache = new HashMap<>();

    /**
     * In order to display the details the constructor of the class.
     * requires the editor that is currently opened and the method rating generated by the plugin.
     * @param editor the currently opened editor
     * @param ratedMethod the method rating generated by the plugin
     */
    public ReadabilityDetailsDialogue(Editor editor, RatedJavaScope ratedMethod) {
        this.project = editor.getProject();
        this.ratedMethod = ratedMethod;
        readabilityService = project.getService(ReadabilityService.class);
    }


    /**
     * Display a readability tree for the rated java scopes.
     * While the tree is constructed (by rating all the scopes) a loading screen will appear in the top
     * left corner of the IDE.
     *
     * After the tree was constructed it is displayed in the plugins tool window
     */
    public void showTreeWithRatings() {
        Task.Backgroundable task = new Task.Backgroundable(project, "Calculating Readability Tree", true) {


            @Override
            public void run(ProgressIndicator progressIndicator) {

                DefaultMutableTreeNode ratingTree = buildTreeWithRatings(progressIndicator);
                SwingUtilities.invokeLater(() -> {
                    displayReadabilityTree(ratingTree);
                });
            }
        };

        ProgressManager.getInstance().run(task);
    }

    /**
     * Create the readability tree by recursively rating all the child scopes of a given java scope.
     * @param rating the readability tree node with the current scopes rating
     * @param scope the java scope corresponding to the given tree node
     * @param foundChildren the number of children (scopes) already found in the parsed java method
     * @param completionService used to rate the different children asynchronous in parallel
     * @return the number of found children after the children of the given scopes were rated recursively
     */
    private int rateChildrenAsync(DefaultMutableTreeNode rating, JavaParseTree scope, int foundChildren, CompletionService<Void> completionService) {

        for(JavaParseTree child: scope.getChildren()) {

            boolean rateCurrentScope = (child.isScope() || child.isDocComment());
            if(!rateCurrentScope) {
                //some codeblocks could be rated but are no blocks beginning and ending with curly brackets.
                //this codeblocks will be skipped and the tree will be built with their children
                if(child.isCodeBlock()) {
                    foundChildren = rateChildrenAsync(rating,child,foundChildren,completionService);
                }
                continue;
            }
            DefaultMutableTreeNode ratingChild = new DefaultMutableTreeNode();
            rating.add(ratingChild);
            foundChildren++;
            completionService.submit(() -> {
                ReadabilityResult result = readabilityService.rateSnippet(child.getCode(), child.getScopeElement());

                ratingChild.setUserObject(createTreeText(child, result.getReadability()));
                return null;
            });

            foundChildren = rateChildrenAsync(ratingChild,child, foundChildren,completionService);
        }
        return foundChildren;
    }

    /**
     * Creates the readability tree for the rated method provided to the Dialogue Object
     * @param progressIndicator an indicator the display the completion percentage of the tree construction in the ui
     * @return the constructed readability tree
     */
    private DefaultMutableTreeNode buildTreeWithRatings(ProgressIndicator progressIndicator) {

        progressIndicator.setIndeterminate(true);
        JavaParseTree methodTree = ratedMethod.getAssociatedScope();

        String methodCode = methodTree.getCode();
        if(treeCache.containsKey(methodCode)) {
            progressIndicator.setFraction(1);
            return treeCache.get(methodCode);
        }

        List<JavaParseTree> blocksRequiringRating = new ArrayList<>();
        blocksRequiringRating.add(methodTree);
        blocksRequiringRating.addAll(methodTree.search(JavaParseTree.scopes));
        blocksRequiringRating.addAll(methodTree.search(JavaParseTree.docComment));


        totalProgressSteps = blocksRequiringRating.size();
        progressIndicator.setIndeterminate(false);

        DefaultMutableTreeNode root = new DefaultMutableTreeNode(createTreeText(methodTree,ratedMethod.getRating()));

        if(totalProgressSteps != 1) {

            ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
            CompletionService<Void> completionService = new ExecutorCompletionService<>(executor);
            int numChildren = rateChildrenAsync(root,methodTree,0,completionService);

            try {
                for (int i = 0; i < numChildren; i++) {
                    completionService.take();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                executor.shutdown();
            }
        }

        treeCache.put(methodCode,root);
        return root;

    }

    /**
     * Create the text to be displayed in a specific tree node
     * @param node the node to generate text for
     * @param readabilityRating the readability rating associated to the node
     * @return the generated text
     */
    private String createTreeText(JavaParseTree node, double readabilityRating) {
        StringBuilder sb = new StringBuilder();
        sb.append("Scope: ");
        sb.append(node.getName());
        sb.append(" - from line ");
        sb.append(node.getStartLine());
        sb.append(" to line ");
        sb.append(node.getEndLine());
        sb.append(" - Rating: ");
        sb.append(String.format("%.2f", readabilityRating));
        return sb.toString();
    }

    /**
     * Displays the tree object generated by rating all the methods scopes in the ui
     * @param root element of the generated readability tree
     */
    private void displayReadabilityTree(DefaultMutableTreeNode root) {
        JPanel content = new JPanel();
        content.setLayout(new BoxLayout(content, BoxLayout.Y_AXIS));
        DefaultTreeModel treeModel = new DefaultTreeModel(root);
        JTree tree = new Tree(treeModel);
        content.add(new JBScrollPane(tree));
        String title = "Readability Tree for Method: " + ratedMethod.getMethodName();
        displayToolWindow(title,content,true);

    }

    /**
     * Displays the improvement hints for the rated method associated the dialogue object.
     * After identifying what hints to display they are shown in 3 different tabs in the plugins tool window.
     */
    public void showImprovementHints() {

        JPanel content = new JPanel();
        content.setLayout(new BoxLayout(content, BoxLayout.Y_AXIS));

        ReadabilityImprover improver = new ReadabilityImprover(ratedMethod);
        Iterator<Improvement> improvementRanking = improver.improve();

        int addedComponents = 0;
        JBTabbedPane tabs = new JBTabbedPane();

        while (improvementRanking.hasNext() && addedComponents < 3) {
            Improvement next = improvementRanking.next();

            try {

                if(addedComponents == 2 && !ratedMethod.hasJavaDoc()) {
                    boolean addedSuccessfully = addJavaDocComment(tabs,addedComponents+1);
                    if(addedSuccessfully) {
                        addedComponents++;
                        continue;
                    }
                }

                String html = MetricHtmlRenderer.createHtml(next);
                JEditorPane htmlPane = new JEditorPane("text/html", html);
                htmlPane.setEditable(false);
                tabs.addTab(String.format("Hint %d", (addedComponents+1)),new JBScrollPane(htmlPane));

                addedComponents++;

            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if(addedComponents < 3 && !ratedMethod.hasJavaDoc()) {
            addJavaDocComment(tabs,addedComponents+1);
        }

        JPanel mainPanel = new JPanel(new BorderLayout());
        mainPanel.add(tabs,BorderLayout.CENTER);
        String title = "Readability hints for Method: " + ratedMethod.getMethodName();
        boolean focus = addedComponents > 0;
        displayToolWindow(title,mainPanel,focus);

    }

    /**
     * Add the java doc comment help text to the tab view used to display the 3 hint texts
     * @param tabs the tab view component
     * @param hintNumber the hint number the java doc comment has
     * @return whether the help text was successfully added to the tab view or not
     */
    private boolean addJavaDocComment(JBTabbedPane tabs, int hintNumber) {

        try {
            String html = MetricHtmlRenderer.createJavaDocHtml(ratedMethod.getMethodName(),hintNumber);
            JEditorPane htmlPane = new JEditorPane("text/html", html);
            htmlPane.setEditable(false);
            tabs.addTab(String.format("Hint %d", hintNumber),new JBScrollPane(htmlPane));
            return true;
        }
        catch (Exception e) {
            e.printStackTrace();
            return false;
        }

    }

    /**
     * Update the content displayed in a specific tab of the tool window.
     * The tool window has multiple tabs, therefore the tab to be displayed must be provided to this method.
     * @param title the title of the tab that should be displayed
     * @param content the content that should be display in the toolwindow
     * @param focus whether to bring the tool window to the foreground after updating the content or not.
     */
    private void displayToolWindow(String title, JComponent content, boolean focus) {
        ToolWindowManager toolWindowManager = ToolWindowManager.getInstance(project);
        ToolWindow toolWindow = toolWindowManager.getToolWindow("ReadabilityPlugin");
        if (toolWindow == null) {
            return;
        }

        ContentManager contentManager = toolWindow.getContentManager();
        ContentFactory contentFactory = contentManager.getFactory();
        Content currentContent = contentManager.findContent(title);
        if(currentContent != null) {
            contentManager.removeContent(currentContent,true);
        }

        Content toolWindowContent = contentFactory.createContent(content, title, false);
        contentManager.addContent(toolWindowContent);
        Runnable focusHandler = focus ? () -> contentManager.setSelectedContent(toolWindowContent) : null;
        toolWindow.activate(focusHandler);
    }
}
