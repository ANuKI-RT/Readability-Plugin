package de.uni_passau.fim.readability_plugin.dialogues;

import de.uni_passau.fim.readability_plugin.readability.ReadabilityImprover.Improvement;
import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateExceptionHandler;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.util.HashMap;
import java.util.Map;

/**
 * In the plugin metric help texts must be displayed.
 * the content of these help texts is provided as html generated by util methods
 * implemented in this class.
 */
public class MetricHtmlRenderer {

    private static Map<String,String> metricMapping = createMetricMapping();
    private static Configuration config = createConfig();

    private MetricHtmlRenderer() {

    }

    /**
     * JavaDoc is a special hint not directly mapped to a readability metric.
     * this method will return the JavaDoc help text as html.
     * @param methodName the method that requires javadoc
     * @param hintNumber the hint number associated to the help text (can be 1 - 3 as 3 hints can be displayed)
     * @return the JavaDoc in HTML format
     * @throws Exception if an error appears during the html rendering
     */
    public static String createJavaDocHtml(String methodName, int hintNumber) throws Exception {
        StringWriter stringWriter = new StringWriter();
        Template javadocTemplate = config.getTemplate("javadoc.html");
        Map<String, Object> javadocModel = new HashMap<>();
        javadocModel.put("ranking",hintNumber);
        javadocModel.put("methodName",methodName);
        javadocTemplate.process(javadocModel,stringWriter);
        return stringWriter.toString();
    }

    /**
     * Create a readability help text.
     * The help text is based in a readability metric that must be improved.
     * The method will provide a html with the help text associated to the improved plugin.
     * The text will also include the metric value of the actual code and the value good readable code
     * should have.
     * @param metricImprovement the metric to improve including the metrics actual and target value
     * @return the rendered help text in HTML format
     * @throws Exception if an error appears during the html rendering
     */
    public static String createHtml(Improvement metricImprovement) throws Exception {
        Element xml = getHintXml(metricImprovement);
        StringWriter stringWriter = new StringWriter();
        Template hintTemplate = config.getTemplate("hint.html");

        Map<String, Object> hintModel = new HashMap<>();
        hintModel.put("ranking", metricImprovement.getRanking());
        hintModel.put("metricName",getTagContent(xml,"metricName",false));


        String improvementPercentage = String.format("%.2f", metricImprovement.getReadabilityImprovement() * 100);
        hintModel.put("possibleImprovement",improvementPercentage );

        double actualScore = metricImprovement.getActualMetricValue();
        double goodScore = metricImprovement.getImprovedMetricValue();

        hintModel.put("actualScore",actualScore);
        hintModel.put("goodScore",goodScore);

        String improvementTask = actualScore < goodScore ? "increase":"reduce";
        hintModel.put("improvementTask",improvementTask);

        hintModel.put("metricDescription",getTagContent(xml,"metricDescription",true));
        hintModel.put("goodCodeDescription",getTagContent(xml,"goodCodeDescription",true));
        hintModel.put("badCodeDescription",getTagContent(xml,"badCodeDescription",true));
        hintModel.put("goodCode",getTagContent(xml,"goodCode",false));
        hintModel.put("badCode",getTagContent(xml,"badCode",false));

        hintTemplate.process(hintModel,stringWriter);
        return stringWriter.toString();
    }

    /**
     * The properties of the help texts are stored as static xml files in the resources/metrics_hints/xml folder.
     * This method can be used to extract a specific property identified by a tag name value from a given xml object.
     * @param xml the xml to extract the properties from
     * @param tagName the tagName associated with the property to extract
     * @param addBreakTags weather to replace \n characters with break tags in the return property string
     * @return the extracted property value
     */
    private static String getTagContent(Element xml, String tagName, boolean addBreakTags) {
        NodeList list = xml.getElementsByTagName(tagName);
        Node firstTag = list.item(0);
        String tagContent = firstTag.getTextContent();
        if(!addBreakTags) {
            return tagContent;
        }
        return tagContent.replaceAll("(\r\n|\n)", "<br />");

    }

    /**
     * The properties of the help texts are stored as static xml files in the resources/metrics_hints/xml folder.
     * This method will provide the xml content if the file linked to a metric that should be improved.
     * The metric name is included in the improvement object. Using this name the file will be fetched from the
     * resources and parsed to a xml element.
     * @param improvement the Improvement object to take the metric name from.
     * @return
     * @throws ParserConfigurationException if the xml parsed config is invalid
     * @throws IOException if the target xml file could not be fetched from the resources folder
     * @throws SAXException if the xml content is invalid in therefore the parsing process failed
     */
    private static Element getHintXml(Improvement improvement) throws ParserConfigurationException, IOException, SAXException {

        String metricName = metricMapping.get(improvement.getMetric());
        String metricXml = "/metric_hints/xml/" + metricName+ ".xml";
        InputStream stream = MetricHtmlRenderer.class.getResourceAsStream(metricXml);
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(stream);
        document.getDocumentElement().normalize();
        return document.getDocumentElement();
    }

    /**
     * Provide the Configuration used by apache freemarker library in order to render the html strings
     * @return the freemarked config
     */
    private static Configuration createConfig() {
        Configuration config = new Configuration(Configuration.VERSION_2_3_31);
        config.setClassForTemplateLoading(MetricHtmlRenderer.class, "/metric_hints/html");
        config.setDefaultEncoding("UTF-8");
        config.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
        config.setLogTemplateExceptions(true);
        config.setWrapUncheckedExceptions(true);
        return config;
    }

    /**
     * Every Code readability metric has a associated display name.
     * The Map returned by this method can be used to map the display name to the actual metric
     * @return the metric mapping object
     */
    private static Map<String,String> createMetricMapping() {
        Map<String,String> mapping = new HashMap<>();
        mapping.put("New Commented words MAX","new_commented_words_max");
        mapping.put("New Synonym commented words MAX","new_synonym_commented_words_max");
        mapping.put("New Text Coherence MAX","new_text_coherence_max");
        mapping.put("BW Avg comparisons","bw_avg_comparisons");
        mapping.put("BW Avg numbers","bw_avg_numbers");
        mapping.put("BW Avg parenthesis","bw_avg_parenthesis");
        mapping.put("BW Max line length","bw_max_line_length");
        mapping.put("BW Max number of identifiers","bw_max_number_of_identifiers");
        mapping.put("BW Max numbers","bw_max_numbers");
        mapping.put("Posnett volume","posnett_volume");
        mapping.put("Dorn DFT Commas","dorn_dft_commas");
        mapping.put("Dorn DFT Comparisons","dorn_dft_comparisons");
        mapping.put("Dorn DFT Keywords","dorn_dft_keywords");
        mapping.put("Dorn DFT LineLengths","dorn_dft_linelengths");
        mapping.put("Dorn DFT Periods","dorn_dft_periods");
        mapping.put("Dorn DFT Spaces","dorn_dft_spaces");
        mapping.put("Dorn Visual Y Comments","dorn_visual_y_comments");
        mapping.put("Dorn Visual Y Identifiers","dorn_visual_y_identifiers");
        mapping.put("Dorn Visual Y Keywords","dorn_visual_y_keywords");
        mapping.put("Dorn Visual Y Numbers","dorn_visual_y_numbers");
        mapping.put("Dorn Areas Comments","dorn_areas_comments");
        mapping.put("Dorn Areas Identifiers","dorn_areas_identifiers");
        mapping.put("Dorn Areas Keywords/Identifiers","dorn_areas_keywords_identifiers");
        mapping.put("Dorn align blocks","dorn_align_blocks");
        return mapping;
    }

}
